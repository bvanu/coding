/** 
LinkedIn
**/

/**
Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.

Example:
Assume that words = ["practice", "makes", "perfect", "coding", "makes"].

Input: word1 = “coding”, word2 = “practice”
Output: 3
Input: word1 = "makes", word2 = "coding"
Output: 1
Note:
You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.

Complexity Analysis:
The time complexity is O(n)O(n). This problem is inherently linear; we cannot do better than O(n)O(n) because at the very least, we have to read the entire input.
Space complexity is O(1)O(1), since no additional space is allocated.

**/


class Solution {
    /**
    Approach #2 (One-pass)
Algorithm

We can greatly improve on the brute-force approach by keeping two indices i1 and i2 where we store the most recent locations of word1 and word2. Each time we find a new occurrence of one of the words, we do not need to search the entire array for the other word, since we already have the index of its most recent occurrence.
**/
    public int shortestDistance(String[] words, String word1, String word2) {
        if(words==null || words.length<1)
            return -1;
        
        // Are words in list? Assume they are else handle this case too
        
        // Are words equal?
        if(word1.equals(word2))
            return 0;
                
        int i1 = -1;
        int i2 = -1;
        int shortestDistance = words.length;
        
        // Find indices of word1 and word2 - TC: O(n)
        for(int i=0; i<words.length; i++)
        {
            if(words[i].equals(word1))
                i1 = i;
            else if(words[i].equals(word2))
                i2 = i;
            
            if(i1!=-1 && i2!=-1)
            {
                shortestDistance = Math.min(shortestDistance, Math.abs(i1-i2));
            }
        }
        
        return shortestDistance;
    }
}
